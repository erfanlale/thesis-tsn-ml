###############################################################
# MinimalPSFP-Attack-ML/simulations/omnetpp.ini
# 
# Minimal TSN Attack Scenario Simulation for ML Training
# Features:
# - Minimal 7-node topology for fast simulation
# - 500ms simulation time for rapid data generation
# - 4 labeled attack scenarios for ML training
# - PSFP configuration for attack detection
# - Optimized for ML dataset generation
###############################################################

[General]
network = MinimalAttackNetwork
sim-time-limit = 500ms
description = "Minimal TSN attack scenarios for ML training (500ms)"

# ---- Interface Bitrate Configuration ----
# The bitrate must match the channel type:
# - Eth1G channels require 1Gbps bitrate
# - Eth100M channels require 100Mbps bitrate

# mainECU uses Eth1G channel, so needs 1Gbps
*.centralSwitch.eth[1].bitrate = 1Gbps
*.mainECU.eth[0].bitrate = 1Gbps

# All other connections use Eth100M channels
*.*.eth[*].bitrate = 100Mbps

# ---- Network Configuration ----
*.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/></config>")

# ---- TSN Device Configuration ---- 
*.centralSwitch.typename = "TsnSwitch"
*.mainECU.typename = "TsnDevice"
*.criticalSensor.typename = "TsnDevice"
*.display.typename = "TsnDevice"
*.attackerExternal.typename = "TsnDevice"
*.compromisedNode.typename = "TsnDevice"
*.masterClock.typename = "TsnClock"

# ---- Time Synchronization Configuration ----
*.*.hasTimeSynchronization = true
*.*.clock.oscillator.driftRate = uniform(-20ppm, 20ppm)

# gPTP master configuration
*.masterClock.gptp.masterPorts = ["eth0"]

# gPTP bridge configuration for central switch
*.centralSwitch.gptp.masterPorts = ["eth1", "eth2", "eth3", "eth4", "eth5"]

# ---- TSN Stream Configuration ----
*.*.hasOutgoingStreams = true
*.centralSwitch.hasEgressTrafficShaping = true
*.centralSwitch.hasIngressTrafficFiltering = true

# ---- Normal Traffic Applications ----
# Critical sensor data (CDT - highest priority) - TSN COMPLIANT
*.criticalSensor.numApps = 1
*.criticalSensor.app[0].typename = "UdpSourceApp"
*.criticalSensor.app[0].source.packetNameFormat = "SENSOR-%c"
*.criticalSensor.app[0].source.packetLength = 175B  # TSN standard packet size
*.criticalSensor.app[0].source.productionInterval = 500us  # 2kHz TSN CDT standard
*.criticalSensor.app[0].io.destAddress = "mainECU"
*.criticalSensor.app[0].io.destPort = 5000
*.criticalSensor.app[0].source.clockModule = "^.^.clock"

# Main ECU receiving critical data
*.mainECU.numApps = 2
*.mainECU.app[0].typename = "UdpSinkApp"
*.mainECU.app[0].io.localPort = 5000  # Critical sensor data

# Display status updates (Class A traffic) - TSN COMPLIANT
*.mainECU.app[1].typename = "UdpSourceApp"
*.mainECU.app[1].source.packetNameFormat = "STATUS-%c"
*.mainECU.app[1].source.packetLength = 325B  # TSN standard packet size
*.mainECU.app[1].source.productionInterval = 250us  # 4kHz TSN Class A standard
*.mainECU.app[1].io.destAddress = "display"
*.mainECU.app[1].io.destPort = 6000
*.mainECU.app[1].source.clockModule = "^.^.clock"

# Display receiving status
*.display.numApps = 1
*.display.app[0].typename = "UdpSinkApp"
*.display.app[0].io.localPort = 6000

# ============================================================================
# PSFP CONFIGURATION - COMPREHENSIVE IEEE 802.1Qci IMPLEMENTATION
# ============================================================================
# 
# This section implements complete Per-Stream Filtering and Policing (PSFP)
# as defined in IEEE 802.1Qci standard. PSFP is the CORE foundation of this
# project and maintains FULL complexity without any simplification.
#
# PSFP Components:
# 1. Stream Identification - Classify packets into traffic streams
# 2. Stream Filtering - Apply per-stream policies 
# 3. Stream Metering - Traffic policing with committed/excess rates
# 4. Stream Gating - Time-aware admission control
# 5. Stream Encoding/Decoding - PCP-based priority marking
# ============================================================================

# ---- PSFP Stream Identification and Classification ----
# ALL switches implement comprehensive stream classification for PSFP compliance
*.centralSwitch.bridging.streamCoder.decoder.mapping = [{source: "criticalSensor", pcp: 7, stream: "critical_control"}, {source: "mainECU", pcp: 5, stream: "status_updates"}, {source: "attackerExternal", pcp: 0, stream: "external_attack"}, {source: "compromisedNode", pcp: 0, stream: "compromised_attack"}]

*.centralSwitch.bridging.streamCoder.encoder.mapping = [{stream: "critical_control", pcp: 7}, {stream: "status_updates", pcp: 5}, {stream: "external_attack", pcp: 0}, {stream: "compromised_attack", pcp: 0}]

# ---- PSFP Stream Filtering Configuration ----
# Full implementation of IEEE 802.1Qci stream filtering
*.centralSwitch.bridging.streamFilter.ingress.numStreams = 4
*.centralSwitch.bridging.streamFilter.ingress.classifier.mapping = {"critical_control": 0, "status_updates": 1, "external_attack": 2, "compromised_attack": 3}

# ---- PSFP Stream Metering (Traffic Policing) ----
# Implements two-rate three-color marker per IEEE 802.1Qci
*.centralSwitch.bridging.streamFilter.ingress.meter[*].typename = "SingleRateTwoColorMeter"

# PSFP Meter Display Names (for monitoring and debugging)
*.centralSwitch.bridging.streamFilter.ingress.meter[0].display-name = "critical_control"
*.centralSwitch.bridging.streamFilter.ingress.meter[1].display-name = "status_updates"
*.centralSwitch.bridging.streamFilter.ingress.meter[2].display-name = "external_attack"
*.centralSwitch.bridging.streamFilter.ingress.meter[3].display-name = "compromised_attack"

# ---- PSFP Committed Information Rate (CIR) Configuration ----
# Critical control traffic - highest priority, generous allocation
*.centralSwitch.bridging.streamFilter.ingress.meter[0].committedInformationRate = 10Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[0].committedBurstSize = 5kB
*.centralSwitch.bridging.streamFilter.ingress.meter[0].excessInformationRate = 5Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[0].excessBurstSize = 3kB

# Status updates - medium priority
*.centralSwitch.bridging.streamFilter.ingress.meter[1].committedInformationRate = 5Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[1].committedBurstSize = 3kB
*.centralSwitch.bridging.streamFilter.ingress.meter[1].excessInformationRate = 2Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[1].excessBurstSize = 1kB

# Attack traffic - low priority, limited allocation for detection
*.centralSwitch.bridging.streamFilter.ingress.meter[2].committedInformationRate = 1Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[2].committedBurstSize = 1kB
*.centralSwitch.bridging.streamFilter.ingress.meter[2].excessInformationRate = 500kbps
*.centralSwitch.bridging.streamFilter.ingress.meter[2].excessBurstSize = 500B

*.centralSwitch.bridging.streamFilter.ingress.meter[3].committedInformationRate = 1Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[3].committedBurstSize = 1kB
*.centralSwitch.bridging.streamFilter.ingress.meter[3].excessInformationRate = 500kbps
*.centralSwitch.bridging.streamFilter.ingress.meter[3].excessBurstSize = 500B

# ---- PSFP Stream Identification in End Devices ----
# Critical Sensor stream identification
*.criticalSensor.bridging.streamIdentifier.identifier.mapping = [{stream: "critical_control", packetFilter: expr(has(udp))}]
*.criticalSensor.bridging.streamCoder.encoder.mapping = [{stream: "critical_control", pcp: 7}]

# Main ECU stream identification  
*.mainECU.bridging.streamIdentifier.identifier.mapping = [{stream: "status_updates", packetFilter: expr(has(udp))}]
*.mainECU.bridging.streamCoder.encoder.mapping = [{stream: "status_updates", pcp: 5}]

# Display device stream handling
*.display.bridging.streamIdentifier.identifier.mapping = [{stream: "display_data", packetFilter: expr(has(udp))}]
*.display.bridging.streamCoder.encoder.mapping = [{stream: "display_data", pcp: 3}]

# Attack device stream identification (for analysis)
*.attackerExternal.bridging.streamIdentifier.identifier.mapping = [{stream: "external_attack", packetFilter: expr(has(udp))}]
*.attackerExternal.bridging.streamCoder.encoder.mapping = [{stream: "external_attack", pcp: 0}]

*.compromisedNode.bridging.streamIdentifier.identifier.mapping = [{stream: "compromised_attack", packetFilter: expr(has(udp))}]
*.compromisedNode.bridging.streamCoder.encoder.mapping = [{stream: "compromised_attack", pcp: 0}]

# ---- IEEE 802.1Qbv Time-Aware Shaping (TAS) Configuration ----
# Full 8-priority traffic class implementation
*.centralSwitch.eth[*].macLayer.queue.numTrafficClasses = 8
*.centralSwitch.eth[*].macLayer.queue.classifier.typename = "PcpClassifier"
*.centralSwitch.eth[*].macLayer.queue.classifier.pcpToGateIndex = [0, 1, 2, 3, 4, 5, 6, 7]

# ---- PSFP Gate Control Configuration ----
# Implements time-aware gate control per IEEE 802.1Qbv
*.centralSwitch.eth[*].macLayer.queue.gate[*].typename = "PeriodicGate"
*.centralSwitch.eth[*].macLayer.queue.gate[7].durations = [250us, 250us]  # Critical control (PCP 7)
*.centralSwitch.eth[*].macLayer.queue.gate[6].durations = [200us, 300us]  # High priority
*.centralSwitch.eth[*].macLayer.queue.gate[5].durations = [150us, 350us]  # Status updates (PCP 5)
*.centralSwitch.eth[*].macLayer.queue.gate[4].durations = [100us, 400us]  # Video traffic
*.centralSwitch.eth[*].macLayer.queue.gate[3].durations = [100us, 400us]  # Voice traffic
*.centralSwitch.eth[*].macLayer.queue.gate[2].durations = [50us, 450us]   # Background
*.centralSwitch.eth[*].macLayer.queue.gate[1].durations = [50us, 450us]   # Spare
*.centralSwitch.eth[*].macLayer.queue.gate[0].durations = [25us, 475us]   # Best effort/attacks

# ---- PSFP Administrative Configuration ----
# Enable comprehensive PSFP features across all switches
*.centralSwitch.hasStreamRedundancy = false  # Simplified for minimal topology
*.centralSwitch.hasIngressTrafficFiltering = true
*.centralSwitch.hasEgressTrafficShaping = true
*.centralSwitch.hasStreamFiltering = true
*.centralSwitch.hasStreamPolicing = true

# ---- PSFP Operational Parameters ----
# Maximum frame size enforcement per stream
*.centralSwitch.bridging.streamFilter.ingress.meter[0].maxFrameSize = 1522B  # Critical control
*.centralSwitch.bridging.streamFilter.ingress.meter[1].maxFrameSize = 1522B  # Status updates  
*.centralSwitch.bridging.streamFilter.ingress.meter[2].maxFrameSize = 1522B  # External attack
*.centralSwitch.bridging.streamFilter.ingress.meter[3].maxFrameSize = 1522B  # Compromised attack

# PSFP recovery behavior
*.centralSwitch.bridging.streamFilter.ingress.meter[*].colorAwareMode = false
*.centralSwitch.bridging.streamFilter.ingress.meter[*].markingEnabled = true

# ============================================================================
# TSN & PSFP METRICS RECORDING CONFIGURATION 
# ============================================================================
# 
# COMPREHENSIVE data collection for PSFP analysis and ML training.
# This section records ALL critical TSN and PSFP metrics without simplification.
# Essential for understanding PSFP behavior and training ML models.
# ============================================================================

# ---- Core TSN Performance Metrics ----
# 1. End-to-End Delay Metrics (Critical for TSN timing analysis)
**.app[*].endToEndDelay:vector.result-recording-modes = all
**.app[*].endToEndDelay:vector.vector-recording = true
**.app[*].endToEndDelay:histogram.result-recording-modes = all

# 2. Throughput and Bandwidth Metrics
**.bitrate:vector.result-recording-modes = all
**.bitrate:vector.vector-recording = true
**.throughput:vector.result-recording-modes = all
**.throughput:vector.vector-recording = true
**.datarate:vector.result-recording-modes = all
**.datarate:vector.vector-recording = true

# 3. Queue Management Metrics (Essential for PSFP analysis)
**.queue.queueLength:vector.result-recording-modes = all
**.queue.queueLength:vector.vector-recording = true
**.queue.queueingTime:vector.result-recording-modes = all
**.queue.queueingTime:vector.vector-recording = true
**.queue.queueBitLength:vector.result-recording-modes = all
**.queue.queueBitLength:vector.vector-recording = true

# 4. Packet Statistics (Attack detection features)
**.packetDropped:count.result-recording-modes = all
**.packetDropped:vector.result-recording-modes = all
**.packetDropped:vector.vector-recording = true
**.packetSent:count.result-recording-modes = all
**.packetReceived:count.result-recording-modes = all
**.rxPkOk:count.result-recording-modes = all
**.rxPkOk:vector.result-recording-modes = all
**.txPk:count.result-recording-modes = all
**.txPk:vector.result-recording-modes = all

# ---- PSFP-Specific Metrics (CORE PROJECT FOUNDATION) ----
# 5. Stream Filtering and Policing Metrics
**.bridging.streamFilter.ingress.meter[*].committedConformingPackets:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedConformingPackets:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedConformingPackets:vector.vector-recording = true

**.bridging.streamFilter.ingress.meter[*].committedNonConformingPackets:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedNonConformingPackets:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedNonConformingPackets:vector.vector-recording = true

**.bridging.streamFilter.ingress.meter[*].excessConformingPackets:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].excessConformingPackets:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].excessConformingPackets:vector.vector-recording = true

**.bridging.streamFilter.ingress.meter[*].packetFiltered:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].packetFiltered:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].packetFiltered:vector.vector-recording = true

# 6. Stream Classification Metrics
**.bridging.streamCoder.packetEncoded:count.result-recording-modes = all
**.bridging.streamCoder.packetDecoded:count.result-recording-modes = all
**.bridging.streamIdentifier.packetClassified:count.result-recording-modes = all
**.bridging.streamIdentifier.packetClassified:vector.result-recording-modes = all
**.bridging.streamIdentifier.packetClassified:vector.vector-recording = true

# 7. Time-Aware Shaping Metrics
**.queue.transmissionGate[*].gateStateChanged:vector.result-recording-modes = all
**.queue.transmissionGate[*].gateStateChanged:vector.vector-recording = true
**.queue.transmissionSelectionAlgorithm[*].credit:vector.result-recording-modes = all
**.queue.transmissionSelectionAlgorithm[*].credit:vector.vector-recording = true

# 8. TSN Time Synchronization Metrics (gPTP)
**.gptp.clockServo.offsetNanoseconds:vector.result-recording-modes = all
**.gptp.clockServo.offsetNanoseconds:vector.vector-recording = true
**.gptp.clockServo.driftPpm:vector.result-recording-modes = all
**.gptp.clockServo.driftPpm:vector.vector-recording = true
**.gptp.clockServo.rateRatio:vector.result-recording-modes = all
**.gptp.clockServo.rateRatio:vector.vector-recording = true

# 9. MAC Layer Metrics (Critical for timing analysis)
**.mac.txPk:count.result-recording-modes = all
**.mac.rxPkOk:count.result-recording-modes = all
**.mac.frameSequenceErrors:count.result-recording-modes = all
**.mac.alignmentErrors:count.result-recording-modes = all

# 10. Physical Layer Metrics
**.phy.txPk:count.result-recording-modes = all
**.phy.rxPkOk:count.result-recording-modes = all
**.phy.symbolErrors:count.result-recording-modes = all

# ---- Attack Detection Specific Metrics ----
# 11. Flow-based metrics for anomaly detection
**.ipv4.routingTable.routeAdded:count.result-recording-modes = all
**.ipv4.routingTable.routeDeleted:count.result-recording-modes = all
**.udp.packetSent:count.result-recording-modes = all
**.udp.packetReceived:count.result-recording-modes = all
**.udp.passedUpPk:count.result-recording-modes = all

# 12. Priority-based traffic analysis
**.pcp0:count.result-recording-modes = all
**.pcp1:count.result-recording-modes = all
**.pcp2:count.result-recording-modes = all
**.pcp3:count.result-recording-modes = all
**.pcp4:count.result-recording-modes = all
**.pcp5:count.result-recording-modes = all
**.pcp6:count.result-recording-modes = all
**.pcp7:count.result-recording-modes = all

# ---- Attack Applications Configuration ----
# Disabled by default, enabled in specific attack scenarios
*.attackerExternal.numApps = 0
*.compromisedNode.numApps = 0

# ---- Visualization Configuration ----
*.visualizer.typename = "IntegratedMultiCanvasVisualizer"

# Data link activity visualization
*.visualizer.dataLinkVisualizer.displayLinks = true
*.visualizer.dataLinkVisualizer.activityLevel = "protocol"
*.visualizer.dataLinkVisualizer.fadeOutMode = "simulationTime"
*.visualizer.dataLinkVisualizer.fadeOutTime = 0.2s

# Statistical visualization
*.visualizer.statisticVisualizer.displayStatistics = true
*.visualizer.statisticVisualizer.signalName = "packetReceived"
*.visualizer.statisticVisualizer.sourceFilter = "**.app[*]"
*.visualizer.statisticVisualizer.format = "count"

# ---- LIGHTWEIGHT ML FEATURE COLLECTION ----
# Disable all default result recording - use DataCollector for targeted signal aggregation  
*.**.result-recording-modes = default
# Enable statistics recording for ML analysis
*.**.vector-recording = true
*.**.scalar-recording = true

# Enable specific network statistics for ML features  
**.app*.packetSent:count.result-recording-modes = all
**.app*.packetReceived:count.result-recording-modes = all
**.udp.packetSent:count.result-recording-modes = all
**.udp.packetReceived:count.result-recording-modes = all
**.queue.queueLength:last.result-recording-modes = all
**.queue.queueLength:max.result-recording-modes = all
**.queue.queueLength:timeavg.result-recording-modes = all
**.queue.outgoingPackets:count.result-recording-modes = all
**.queue.incomingPackets:count.result-recording-modes = all
**.queue.queueingTime:mean.result-recording-modes = all
**.queue.queueingTime:max.result-recording-modes = all
**.macLayer.*.packetDropped:count.result-recording-modes = all

# TEMPORARY: Enable signal recording to verify signals are being emitted
**.packetSent:count.result-recording-modes = all
**.packetReceived:count.result-recording-modes = all
**.packetDropped:count.result-recording-modes = all
**.packetPulled:count.result-recording-modes = all
**.packetPushed:count.result-recording-modes = all
**.app*.packetSent:count.result-recording-modes = all

# Note: DataCollector subscribes to signals directly without recording to .vec files
# This produces a single CSV file with ML-ready features per scenario

# =================================================================
# ATTACK SCENARIO CONFIGURATIONS (4 scenarios for ML training)
# Each scenario runs for 500ms with predetermined attack timing
# =================================================================

[Config Baseline]
extends = General
description = "Baseline: Normal TSN operation without attacks (Label: normal)"

# === NORMAL TSN TRAFFIC APPLICATIONS ===
# Critical sensor -> mainECU (real-time safety-critical)
*.criticalSensor.numApps = 1
*.criticalSensor.app[0].typename = "UdpSourceApp"
*.criticalSensor.app[0].source.packetNameFormat = "CRITICAL_SENSOR-%c"
*.criticalSensor.app[0].source.packetLength = 175B
*.criticalSensor.app[0].source.productionInterval = 1ms  # 1kHz safety sensor
*.criticalSensor.app[0].source.startTime = 10ms
*.criticalSensor.app[0].io.destAddress = "mainECU"
*.criticalSensor.app[0].io.destPort = 5000

# Display unit -> mainECU (periodic updates)
*.display.numApps = 1  
*.display.app[0].typename = "UdpSourceApp"
*.display.app[0].source.packetNameFormat = "DISPLAY_UPDATE-%c"
*.display.app[0].source.packetLength = 120B
*.display.app[0].source.productionInterval = 50ms  # 20Hz display updates
*.display.app[0].source.startTime = 15ms
*.display.app[0].io.destAddress = "mainECU"
*.display.app[0].io.destPort = 6000

# mainECU -> display (response traffic)
*.mainECU.numApps = 1
*.mainECU.app[0].typename = "UdpSinkApp"
*.mainECU.app[0].io.localPort = 5000

[Config DoSAttack] 
extends = Baseline  # Include normal traffic + DoS attack
description = "DoS flooding attack targeting critical systems (Label: dos_attack)"

# DoS attack: High-rate flooding starting at 100ms, ending at 400ms - TSN AGGRESSIVE
*.attackerExternal.numApps = 1
*.attackerExternal.app[0].typename = "UdpSourceApp"
*.attackerExternal.app[0].source.packetNameFormat = "DOS_FLOOD-%c"
*.attackerExternal.app[0].source.packetLength = 1500B  # Maximum Ethernet frame
*.attackerExternal.app[0].source.productionInterval = 10us  # 100kHz aggressive attack rate
*.attackerExternal.app[0].source.startTime = 100ms
*.attackerExternal.app[0].source.stopTime = 400ms
*.attackerExternal.app[0].io.destAddress = "mainECU"
*.attackerExternal.app[0].io.destPort = 5000  # Target critical sensor port

[Config TimingAttack]
extends = Baseline  # Include normal traffic + timing attack
description = "Timing attack disrupting TSN synchronization (Label: timing_attack)"

# Severe clock drift attack
*.compromisedNode.clock.oscillator.driftRate = 500ppm  # Very high drift

# Timing disruption packets - targeting centralSwitch instead of masterClock
*.compromisedNode.numApps = 1
*.compromisedNode.app[0].typename = "UdpSourceApp"
*.compromisedNode.app[0].source.packetNameFormat = "TIMING_ATTACK-%c"
*.compromisedNode.app[0].source.packetLength = 64B
*.compromisedNode.app[0].source.productionInterval = uniform(10us, 100us)  # Random timing
*.compromisedNode.app[0].source.startTime = 50ms
*.compromisedNode.app[0].source.stopTime = 450ms
*.compromisedNode.app[0].io.destAddress = "mainECU"
*.compromisedNode.app[0].io.destPort = 8888

[Config SpoofingAttack]
extends = Baseline  # Include normal traffic + spoofing attack
description = "Spoofing attack impersonating critical sensor (Label: spoofing_attack)"

# Compromised node impersonates critical sensor - TSN AGGRESSIVE SPOOFING
*.compromisedNode.numApps = 1
*.compromisedNode.app[0].typename = "UdpSourceApp"
*.compromisedNode.app[0].source.packetNameFormat = "SPOOFED_SENSOR-%c"
*.compromisedNode.app[0].source.packetLength = 175B  # Match legitimate sensor
*.compromisedNode.app[0].source.productionInterval = 100us  # 10x faster than TSN standard
*.compromisedNode.app[0].source.startTime = 150ms
*.compromisedNode.app[0].source.stopTime = 350ms
*.compromisedNode.app[0].io.destAddress = "mainECU"
*.compromisedNode.app[0].io.destPort = 5000  # Same port as critical sensor 