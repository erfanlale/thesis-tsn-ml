###############################################################
# MinimalPSFP-Attack-ML/simulations/omnetpp.ini
# 
# Minimal TSN Attack Scenario Simulation for ML Training
# Features:
# - Minimal 7-node topology for fast simulation
# - 500ms simulation time for rapid data generation
# - 4 labeled attack scenarios for ML training
# - PSFP configuration for attack detection
# - Optimized for ML dataset generation
###############################################################

[General]
network = MinimalAttackNetwork
sim-time-limit = 500ms
description = "Minimal TSN attack scenarios for ML training (500ms)"
cmdenv-interactive = false

# ---- Multiple Runs Configuration ----
# Enable multiple runs with different random seeds
# This allows the "Run number" field to be editable in the IDE
# make runs reproducible and different
repeat = 10
seed-set = ${repetition}

# DataCollector CSV output (flat results directory)
*.dataCollector.outputFile = "results_flat/tsn_signals_${configname}-#${repetition}.csv"

# ---- User Interface Configuration ----
# Default to Cmdenv for fast unattended batch runs; you can override in Run Config dialog
user-interface = "Cmdenv"

# ---- Debugging Configuration ----
# Keep JSON output per run; DataCollector is self-contained


# ---- Interface Bitrate Configuration ----
# Explicit NIC bitrates to match link channels (prevents IFG/PHY timing issues)
*.masterClock.eth[*].bitrate = 100Mbps

# Port mapping on centralSwitch (by connection order in NED):
# [0]=masterClock(Eth100M), [1]=mainECU(Eth1G), [2]=criticalSensor(Eth100M),
# [3]=display(Eth100M), [4]=attackerExternal(Eth100M), [5]=compromisedNode(Eth100M)
*.centralSwitch.eth[0].bitrate = 100Mbps
*.centralSwitch.eth[1].bitrate = 1Gbps
*.centralSwitch.eth[2].bitrate = 100Mbps
*.centralSwitch.eth[3].bitrate = 100Mbps
*.centralSwitch.eth[4].bitrate = 100Mbps
*.centralSwitch.eth[5].bitrate = 100Mbps

*.mainECU.eth[*].bitrate = 1Gbps
*.criticalSensor.eth[*].bitrate = 100Mbps
*.display.eth[*].bitrate = 100Mbps
*.attackerExternal.eth[*].bitrate = 100Mbps
*.compromisedNode.eth[*].bitrate = 100Mbps

# ---- Network Configuration ----
*.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/></config>")

# ---- TSN Device Configuration ---- 
*.centralSwitch.typename = "TsnSwitch"
*.mainECU.typename = "TsnDevice"
*.criticalSensor.typename = "TsnDevice"
*.display.typename = "TsnDevice"
*.attackerExternal.typename = "TsnDevice"
*.compromisedNode.typename = "TsnDevice"
*.masterClock.typename = "TsnClock"

# ---- Time Synchronization Configuration ----
*.*.hasTimeSynchronization = true
*.*.clock.oscillator.driftRate = uniform(-20ppm, 20ppm)

# gPTP master configuration (single GM)
*.masterClock.gptp.masterPorts = ["eth0"]

# gPTP bridge (central switch) configuration
# One slave port facing the grandmaster, master ports facing end stations
*.centralSwitch.gptp.slavePort = "eth0"
*.centralSwitch.gptp.masterPorts = ["eth1","eth2","eth3","eth4","eth5"]

# ---- TSN Stream Configuration ----
*.*.hasOutgoingStreams = true
*.centralSwitch.hasEgressTrafficShaping = true

# ---- Normal Traffic Applications ----
# Define traffic only in specific [Config ...] sections

# ============================================================================
# PSFP CONFIGURATION - COMPREHENSIVE IEEE 802.1Qci IMPLEMENTATION
# ============================================================================
# 
# This section implements complete Per-Stream Filtering and Policing (PSFP)
# as defined in IEEE 802.1Qci standard. PSFP is the CORE foundation of this
# project and maintains FULL complexity without any simplification.
#
# PSFP Components:
# 1. Stream Identification - Classify packets into traffic streams
# 2. Stream Filtering - Apply per-stream policies 
# 3. Stream Metering - Traffic policing with committed/excess rates
# 4. Stream Gating - Time-aware admission control
# 5. Stream Encoding/Decoding - PCP-based priority marking
# ============================================================================

# ---- PSFP Stream Identification and Classification ----
# ALL switches implement comprehensive stream classification for PSFP compliance
# Switch decoder mapping not required; rely on end-host identifiers + classifier mapping

*.centralSwitch.bridging.streamCoder.encoder.mapping = [{stream: "critical_control", pcp: 7}, {stream: "status_updates", pcp: 5}, {stream: "external_attack", pcp: 0}, {stream: "compromised_attack", pcp: 0}]

# ---- PSFP Stream Filtering Configuration ----
# Full implementation of IEEE 802.1Qci stream filtering
*.centralSwitch.bridging.streamFilter.ingress.numStreams = 5
*.centralSwitch.bridging.streamFilter.ingress.classifier.mapping = {"critical_control": 0, "status_updates": 1, "external_attack": 2, "compromised_attack": 3, "display_data": 4}

# ---- PSFP Stream Metering (Traffic Policing) ----
# Use INET queueing meter that implements IPacketMeter
*.centralSwitch.bridging.streamFilter.ingress.meter[*].typename = "DualRateThreeColorMeter"

# PSFP Meter Display Names (for monitoring and debugging)
*.centralSwitch.bridging.streamFilter.ingress.meter[0].display-name = "critical_control"
*.centralSwitch.bridging.streamFilter.ingress.meter[1].display-name = "status_updates"
*.centralSwitch.bridging.streamFilter.ingress.meter[2].display-name = "external_attack"
*.centralSwitch.bridging.streamFilter.ingress.meter[3].display-name = "compromised_attack"
*.centralSwitch.bridging.streamFilter.ingress.meter[4].display-name = "display_data"

# ---- PSFP Committed Information Rate (CIR) Configuration ----
# Critical control traffic - highest priority, generous allocation
*.centralSwitch.bridging.streamFilter.ingress.meter[0].committedInformationRate = 10Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[0].committedBurstSize = 5kB
*.centralSwitch.bridging.streamFilter.ingress.meter[0].excessInformationRate = 5Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[0].excessBurstSize = 3kB

# Status updates - medium priority
*.centralSwitch.bridging.streamFilter.ingress.meter[1].committedInformationRate = 5Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[1].committedBurstSize = 3kB
*.centralSwitch.bridging.streamFilter.ingress.meter[1].excessInformationRate = 2Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[1].excessBurstSize = 1kB

# Attack traffic - low priority, limited allocation for detection
*.centralSwitch.bridging.streamFilter.ingress.meter[2].committedInformationRate = 1Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[2].committedBurstSize = 1kB
*.centralSwitch.bridging.streamFilter.ingress.meter[2].excessInformationRate = 500kbps
*.centralSwitch.bridging.streamFilter.ingress.meter[2].excessBurstSize = 500B

*.centralSwitch.bridging.streamFilter.ingress.meter[3].committedInformationRate = 1Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[3].committedBurstSize = 1kB
*.centralSwitch.bridging.streamFilter.ingress.meter[3].excessInformationRate = 500kbps
*.centralSwitch.bridging.streamFilter.ingress.meter[3].excessBurstSize = 500B
*.centralSwitch.bridging.streamFilter.ingress.meter[4].committedInformationRate = 2Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[4].committedBurstSize = 2kB
*.centralSwitch.bridging.streamFilter.ingress.meter[4].excessInformationRate = 1Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[4].excessBurstSize = 1kB

# ---- PSFP Stream Identification in End Devices ----
# Critical Sensor stream identification
*.criticalSensor.bridging.streamIdentifier.identifier.mapping = [{stream: "critical_control", packetFilter: expr(has(udp))}]
*.criticalSensor.bridging.streamCoder.encoder.mapping = [{stream: "critical_control", pcp: 7}]

# Main ECU stream identification  
*.mainECU.bridging.streamIdentifier.identifier.mapping = [{stream: "status_updates", packetFilter: expr(has(udp))}]
*.mainECU.bridging.streamCoder.encoder.mapping = [{stream: "status_updates", pcp: 5}]

# Display device stream handling
*.display.bridging.streamIdentifier.identifier.mapping = [{stream: "display_data", packetFilter: expr(has(udp))}]
*.display.bridging.streamCoder.encoder.mapping = [{stream: "display_data", pcp: 3}]

# Attack device stream identification (for analysis)
*.attackerExternal.bridging.streamIdentifier.identifier.mapping = [{stream: "external_attack", packetFilter: expr(has(udp))}]
*.attackerExternal.bridging.streamCoder.encoder.mapping = [{stream: "external_attack", pcp: 0}]

*.compromisedNode.bridging.streamIdentifier.identifier.mapping = [{stream: "compromised_attack", packetFilter: expr(has(udp))}]
*.compromisedNode.bridging.streamCoder.encoder.mapping = [{stream: "compromised_attack", pcp: 0}]

# ---- IEEE 802.1Qbv Time-Aware Shaping (TAS) Configuration ----
# Full 8-priority traffic class implementation
*.centralSwitch.eth[*].macLayer.queue.numTrafficClasses = 8
*.centralSwitch.eth[*].macLayer.queue.classifier.typename = "PcpClassifier"
*.centralSwitch.eth[*].macLayer.queue.classifier.pcpToGateIndex = [0, 1, 2, 3, 4, 5, 6, 7]

# ---- PSFP Gate Control Configuration ----
# Implements time-aware gate control per IEEE 802.1Qbv
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[*].typename = "PeriodicGate"
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[7].durations = [250us, 250us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[6].durations = [200us, 300us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[5].durations = [150us, 350us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[4].durations = [100us, 400us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[3].durations = [100us, 400us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[2].durations = [50us, 450us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[1].durations = [50us, 450us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[0].durations = [25us, 475us]

# ---- PSFP Administrative Configuration ----
# Enable comprehensive PSFP features across all switches
*.centralSwitch.hasStreamRedundancy = false  # Simplified for minimal topology
*.centralSwitch.hasIngressTrafficFiltering = true
*.centralSwitch.hasEgressTrafficShaping = true
*.centralSwitch.hasStreamFiltering = true
*.centralSwitch.hasStreamPolicing = true

# ---- PSFP Operational Parameters ----
# Keep parameters compatible with DualRateThreeColorMeter
*.centralSwitch.bridging.streamFilter.ingress.meter[*].colorAware = false

# ============================================================================
# TSN & PSFP METRICS RECORDING CONFIGURATION 
# ============================================================================
# 
# COMPREHENSIVE data collection for PSFP analysis and ML training.
# This section records ALL critical TSN and PSFP metrics without simplification.
# Essential for understanding PSFP behavior and training ML models.
# ============================================================================

# ---- Core TSN Performance Metrics ----
# 1. End-to-End Delay Metrics (Critical for TSN timing analysis)
**.app[*].endToEndDelay:vector.result-recording-modes = all
**.app[*].endToEndDelay:vector.vector-recording = true
**.app[*].endToEndDelay:histogram.result-recording-modes = all

# 2. Throughput and Bandwidth Metrics
**.bitrate:vector.result-recording-modes = all
**.bitrate:vector.vector-recording = true
**.throughput:vector.result-recording-modes = all
**.throughput:vector.vector-recording = true
**.datarate:vector.result-recording-modes = all
**.datarate:vector.vector-recording = true

# 3. Queue Management Metrics (Essential for PSFP analysis)
**.queue.queueLength:vector.result-recording-modes = all
**.queue.queueLength:vector.vector-recording = true
**.queue.queueingTime:vector.result-recording-modes = all
**.queue.queueingTime:vector.vector-recording = true
**.queue.queueBitLength:vector.result-recording-modes = all
**.queue.queueBitLength:vector.vector-recording = true

# 4. Packet Statistics (Attack detection features)
**.packetDropped:count.result-recording-modes = all
**.packetDropped:vector.result-recording-modes = all
**.packetDropped:vector.vector-recording = true
**.packetSent:count.result-recording-modes = all
**.packetReceived:count.result-recording-modes = all
**.rxPkOk:count.result-recording-modes = all
**.rxPkOk:vector.result-recording-modes = all
**.txPk:count.result-recording-modes = all
**.txPk:vector.result-recording-modes = all

# ---- PSFP-Specific Metrics (CORE PROJECT FOUNDATION) ----
# 5. Stream Filtering and Policing Metrics
**.bridging.streamFilter.ingress.meter[*].committedConformingPackets:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedConformingPackets:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedConformingPackets:vector.vector-recording = true

**.bridging.streamFilter.ingress.meter[*].committedNonConformingPackets:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedNonConformingPackets:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedNonConformingPackets:vector.vector-recording = true

**.bridging.streamFilter.ingress.meter[*].excessConformingPackets:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].excessConformingPackets:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].excessConformingPackets:vector.vector-recording = true

**.bridging.streamFilter.ingress.meter[*].packetFiltered:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].packetFiltered:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].packetFiltered:vector.vector-recording = true

# 6. Stream Classification Metrics
**.bridging.streamCoder.packetEncoded:count.result-recording-modes = all
**.bridging.streamCoder.packetDecoded:count.result-recording-modes = all
**.bridging.streamIdentifier.packetClassified:count.result-recording-modes = all
**.bridging.streamIdentifier.packetClassified:vector.result-recording-modes = all
**.bridging.streamIdentifier.packetClassified:vector.vector-recording = true

# 7. Time-Aware Shaping Metrics
**.queue.transmissionGate[*].gateStateChanged:vector.result-recording-modes = all
**.queue.transmissionGate[*].gateStateChanged:vector.vector-recording = true
**.queue.transmissionSelectionAlgorithm[*].credit:vector.result-recording-modes = all
**.queue.transmissionSelectionAlgorithm[*].credit:vector.vector-recording = true

# 8. TSN Time Synchronization Metrics (gPTP)
**.gptp.clockServo.offsetNanoseconds:vector.result-recording-modes = all
**.gptp.clockServo.offsetNanoseconds:vector.vector-recording = true
**.gptp.clockServo.driftPpm:vector.result-recording-modes = all
**.gptp.clockServo.driftPpm:vector.vector-recording = true
**.gptp.clockServo.rateRatio:vector.result-recording-modes = all
**.gptp.clockServo.rateRatio:vector.vector-recording = true

# 9. MAC Layer Metrics (Critical for timing analysis)
**.mac.txPk:count.result-recording-modes = all
**.mac.rxPkOk:count.result-recording-modes = all
**.mac.frameSequenceErrors:count.result-recording-modes = all
**.mac.alignmentErrors:count.result-recording-modes = all

# 10. Physical Layer Metrics
**.phy.txPk:count.result-recording-modes = all
**.phy.rxPkOk:count.result-recording-modes = all
**.phy.symbolErrors:count.result-recording-modes = all

# ---- Attack Detection Specific Metrics ----
# 11. Flow-based metrics for anomaly detection
**.ipv4.routingTable.routeAdded:count.result-recording-modes = all
**.ipv4.routingTable.routeDeleted:count.result-recording-modes = all
**.udp.packetSent:count.result-recording-modes = all
**.udp.packetReceived:count.result-recording-modes = all
**.udp.passedUpPk:count.result-recording-modes = all

# 12. Priority-based traffic analysis
**.pcp0:count.result-recording-modes = all
**.pcp1:count.result-recording-modes = all
**.pcp2:count.result-recording-modes = all
**.pcp3:count.result-recording-modes = all
**.pcp4:count.result-recording-modes = all
**.pcp5:count.result-recording-modes = all
**.pcp6:count.result-recording-modes = all
**.pcp7:count.result-recording-modes = all

# ---- Attack Applications Configuration ----
# Disabled by default, enabled in specific attack scenarios
*.attackerExternal.numApps = 0
*.compromisedNode.numApps = 0

# ---- Visualization Configuration ----
*.visualizer.typename = "IntegratedCanvasVisualizer"

# Data link activity visualization
*.visualizer.dataLinkVisualizer.displayLinks = true
*.visualizer.dataLinkVisualizer.activityLevel = "protocol"
*.visualizer.dataLinkVisualizer.fadeOutMode = "simulationTime"
*.visualizer.dataLinkVisualizer.fadeOutTime = 0.2s

# Statistical visualization
*.visualizer.statisticVisualizer.displayStatistics = true
*.visualizer.statisticVisualizer.signalName = "packetReceived"
*.visualizer.statisticVisualizer.sourceFilter = "**.app[*]"
*.visualizer.statisticVisualizer.format = "count"

# ---- DATA COLLECTOR CONFIGURATION ----
# Configure DataCollector for time-windowed CSV output optimized for ML
*.dataCollector.outputFile = "results_flat/tsn_signals_${configname}-#${repetition}.csv"
*.dataCollector.windowLength = 10ms
*.dataCollector.emitCSV = true
*.dataCollector.emitRaw = false
*.dataCollector.emitNDJSON = false

# ---- TSN ML INFERENCE ENGINE CONFIGURATION ----
# Configure ML inference engine for real-time attack detection
*.mlInferenceEngine.modelPath = "../ml_models/tsn_minimal7_fdeep.json"
*.mlInferenceEngine.normPath = "../ml_models/tsn_minimal7_norm.json"
*.mlInferenceEngine.inferenceInterval = 5ms
*.mlInferenceEngine.anomalyThreshold = 0.7

# Keep results in a single flat directory (no nesting)
result-dir = "results_flat"
output-scalar-file = "${resultdir}/${configname}-${repetition}.sca"
output-vector-file = "${resultdir}/${configname}-${repetition}.vec"


# ---- LIGHTWEIGHT ML FEATURE COLLECTION ----
# Keep .vec small: rely on JSON; selectively enable vectors only when debugging
**.result-recording-modes = default
**.vector-recording = false
**.scalar-recording = false

# Optional minimal vectors for debugging (comment out if not needed)
# **.app[*].endToEndDelay:vector.vector-recording = true
# **.queue.queueLength:vector.vector-recording = true
# **.packetDropped:count.result-recording-modes = all

# Note: DataCollector subscribes to signals directly without recording to .vec files
# This produces a single JSON file with ML-ready features per scenario

# =================================================================
# ATTACK SCENARIO CONFIGURATIONS (4 scenarios for ML training)
# Each scenario runs for 500ms with predetermined attack timing
# =================================================================





[Config Baseline]
extends = General
description = "Baseline: Normal TSN operation without attacks (Label: normal)"

# === NORMAL TSN TRAFFIC APPLICATIONS ===
# Critical sensor -> mainECU (real-time safety-critical)
*.criticalSensor.numApps = 1
*.criticalSensor.app[0].typename = "UdpSourceApp"
*.criticalSensor.app[0].source.packetNameFormat = "CRITICAL_SENSOR-%c"
*.criticalSensor.app[0].source.packetLength = 175B
*.criticalSensor.app[0].source.productionInterval = 1ms  # 1kHz safety sensor
*.criticalSensor.app[0].source.startTime = 10ms
*.criticalSensor.app[0].io.destAddress = "mainECU"
*.criticalSensor.app[0].io.destPort = 5000

# Display unit -> mainECU (periodic updates)
*.display.numApps = 1  
*.display.app[0].typename = "UdpSourceApp"
*.display.app[0].source.packetNameFormat = "DISPLAY_UPDATE-%c"
*.display.app[0].source.packetLength = 120B
*.display.app[0].source.productionInterval = 50ms  # 20Hz display updates
*.display.app[0].source.startTime = 15ms
*.display.app[0].io.destAddress = "mainECU"
*.display.app[0].io.destPort = 6000

# mainECU -> display (response traffic)
*.mainECU.numApps = 1
*.mainECU.app[0].typename = "UdpSinkApp"
*.mainECU.app[0].io.localPort = 5000

[Config DoSAttack] 
extends = Baseline  # Include normal traffic + DoS attack
description = "DoS flooding attack targeting critical systems (Label: dos_attack)"

# DoS attack: High-rate flooding starting at 100ms, ending at 400ms - TSN AGGRESSIVE
*.attackerExternal.numApps = 1
*.attackerExternal.app[0].typename = "UdpSourceApp"
*.attackerExternal.app[0].source.packetNameFormat = "DOS_FLOOD-%c"
*.attackerExternal.app[0].source.packetLength = 1500B  # Maximum Ethernet frame
*.attackerExternal.app[0].source.productionInterval = 10us  # 100kHz aggressive attack rate
*.attackerExternal.app[0].source.startTime = 100ms
*.attackerExternal.app[0].source.stopTime = 400ms
*.attackerExternal.app[0].io.destAddress = "mainECU"
*.attackerExternal.app[0].io.destPort = 5000  # Target critical sensor port

[Config TimingAttack]
extends = Baseline  # Include normal traffic + timing attack
description = "Timing attack disrupting TSN synchronization (Label: timing_attack)"

# Severe clock drift attack
*.compromisedNode.clock.oscillator.driftRate = 500ppm  # Very high drift

# Timing disruption packets - targeting centralSwitch instead of masterClock
*.compromisedNode.numApps = 1
*.compromisedNode.app[0].typename = "UdpSourceApp"
*.compromisedNode.app[0].source.packetNameFormat = "TIMING_ATTACK-%c"
*.compromisedNode.app[0].source.packetLength = 64B
*.compromisedNode.app[0].source.productionInterval = uniform(10us, 100us)  # Random timing
*.compromisedNode.app[0].source.startTime = 50ms
*.compromisedNode.app[0].source.stopTime = 450ms
*.compromisedNode.app[0].io.destAddress = "mainECU"
*.compromisedNode.app[0].io.destPort = 8888

[Config SpoofingAttack]
extends = Baseline  # Include normal traffic + spoofing attack
description = "Spoofing attack impersonating critical sensor (Label: spoofing_attack)"

# Compromised node impersonates critical sensor - TSN AGGRESSIVE SPOOFING
*.compromisedNode.numApps = 1
*.compromisedNode.app[0].typename = "UdpSourceApp"
*.compromisedNode.app[0].source.packetNameFormat = "SPOOFED_SENSOR-%c"
*.compromisedNode.app[0].source.packetLength = 175B  # Match legitimate sensor
*.compromisedNode.app[0].source.productionInterval = 100us  # 10x faster than TSN standard
*.compromisedNode.app[0].source.startTime = 150ms
*.compromisedNode.app[0].source.stopTime = 350ms
*.compromisedNode.app[0].io.destAddress = "mainECU"
*.compromisedNode.app[0].io.destPort = 5000  # Same port as critical sensor
