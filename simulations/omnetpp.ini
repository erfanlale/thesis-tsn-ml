###############################################################
# MinimalPSFP-Attack-ML/simulations/omnetpp.ini
# 
# Minimal TSN Attack Scenario Simulation for ML Training
# Features:
# - Minimal 7-node topology for fast simulation
# - 500ms simulation time for rapid data generation
# - 4 labeled attack scenarios for ML training
# - PSFP configuration for attack detection
# - Optimized for ML dataset generation
###############################################################

[General]
network = MinimalAttackNetwork
sim-time-limit = 500ms
description = "Minimal TSN attack scenarios for ML training (500ms)"
cmdenv-interactive = false

# ---- Multiple Runs Configuration ----
# Enable multiple runs with different random seeds
# This allows the "Run number" field to be editable in the IDE
# make runs reproducible and different
repeat = 10
seed-set = ${repetition}

# DataCollector CSV output (flat results directory)
*.dataCollector.outputFile = "results_flat/tsn_signals_${configname}-#${repetition}.csv"

# ---- User Interface Configuration ----
# Default to Cmdenv for fast unattended batch runs; you can override in Run Config dialog
user-interface = "Cmdenv"

# ---- Debugging Configuration ----
# Keep JSON output per run; DataCollector is self-contained


# ---- Interface Bitrate Configuration ----
# Explicit NIC bitrates to match link channels (prevents IFG/PHY timing issues)
*.masterClock.eth[*].bitrate = 100Mbps

# Port mapping on centralSwitch (by connection order in NED):
# [0]=masterClock(Eth100M), [1]=mainECU(Eth1G), [2]=criticalSensor(Eth100M),
# [3]=display(Eth100M), [4]=attackerExternal(Eth100M), [5]=compromisedNode(Eth100M)
*.centralSwitch.eth[0].bitrate = 100Mbps
*.centralSwitch.eth[1].bitrate = 1Gbps
*.centralSwitch.eth[2].bitrate = 100Mbps
*.centralSwitch.eth[3].bitrate = 100Mbps
*.centralSwitch.eth[4].bitrate = 100Mbps
*.centralSwitch.eth[5].bitrate = 100Mbps

*.mainECU.eth[*].bitrate = 1Gbps
*.criticalSensor.eth[*].bitrate = 100Mbps
*.display.eth[*].bitrate = 100Mbps
*.attackerExternal.eth[*].bitrate = 100Mbps
*.compromisedNode.eth[*].bitrate = 100Mbps

# ---- Network Configuration ----
*.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/></config>")

# ---- TSN Device Configuration ---- 
*.centralSwitch.typename = "TsnSwitch"
*.mainECU.typename = "TsnDevice"
*.criticalSensor.typename = "TsnDevice"
*.display.typename = "TsnDevice"
*.attackerExternal.typename = "TsnDevice"
*.compromisedNode.typename = "TsnDevice"
*.masterClock.typename = "TsnClock"

# ---- Transport stack on end-stations (needed by UdpSourceApp/UdpSinkApp) ----
*.mainECU.hasUdp = true
*.criticalSensor.hasUdp = true
*.display.hasUdp = true
*.attackerExternal.hasUdp = true
*.compromisedNode.hasUdp = true

# Ensure IPv4 exists for UDP sockets (StandardHost/TsnDevice stack)
*.mainECU.hasIpv4 = true
*.criticalSensor.hasIpv4 = true
*.display.hasIpv4 = true
*.attackerExternal.hasIpv4 = true
*.compromisedNode.hasIpv4 = true

# ---- Time Synchronization Configuration ----
*.*.hasTimeSynchronization = true
*.*.clock.oscillator.driftRate = uniform(-20ppm, 20ppm)
# gPTP default settings overrides for 500 ms runs
**.gptp.syncInterval = 10ms
**.gptp.syncInitialOffset = 1ms
**.gptp.pdelayInterval = 50ms
**.gptp.pdelayInitialOffset = 1ms

# gPTP master configuration (single GM)
*.masterClock.gptp.masterPorts = ["eth0"]

# gPTP bridge (central switch) configuration
# One slave port facing the grandmaster, master ports facing end stations
*.centralSwitch.gptp.slavePort = "eth0"
*.centralSwitch.gptp.masterPorts = ["eth1","eth2","eth3","eth4","eth5"]

# ---- TSN Stream Configuration ----
*.*.hasOutgoingStreams = true
*.centralSwitch.hasEgressTrafficShaping = true
*.centralSwitch.hasIncomingStreams = true
*.criticalSensor.bridging.streamIdentifier.typename = "StreamIdentifierLayer"
*.criticalSensor.bridging.streamCoder.typename = "StreamCoderLayer"

# ---- Normal Traffic Applications ----
# Define traffic only in specific [Config ...] sections

# ============================================================================
# PSFP CONFIGURATION - COMPREHENSIVE IEEE 802.1Qci IMPLEMENTATION
# ============================================================================
# 
# This section implements complete Per-Stream Filtering and Policing (PSFP)
# as defined in IEEE 802.1Qci standard. PSFP is the CORE foundation of this
# project and maintains FULL complexity without any simplification.
#
# PSFP Components:
# 1. Stream Identification - Classify packets into traffic streams
# 2. Stream Filtering - Apply per-stream policies 
# 3. Stream Metering - Traffic policing with committed/excess rates
# 4. Stream Gating - Time-aware admission control
# 5. Stream Encoding/Decoding - PCP-based priority marking
# ============================================================================

# ---- PSFP Stream Identification and Classification ----
# ALL switches implement comprehensive stream classification for PSFP compliance
# Switch decoder mapping not required; rely on end-host identifiers + classifier mapping

*.centralSwitch.bridging.streamCoder.encoder.mapping = [{stream: "critical_control", pcp: 7, vlan: 10}, {stream: "status_updates", pcp: 5, vlan: 30}, {stream: "display_data", pcp: 3, vlan: 20}, {stream: "external_attack", pcp: 0, vlan: 40}, {stream: "compromised_attack", pcp: 0, vlan: 41}]
*.centralSwitch.bridging.streamCoder.decoder.mapping = [{stream: "critical_control", pcp: 7, destination: "mainECU"}, {stream: "status_updates", pcp: 5, destination: "mainECU"}, {stream: "display_data", pcp: 3, destination: "mainECU"}, {stream: "external_attack", pcp: 0, source: "attackerExternal", destination: "mainECU"}, {stream: "compromised_attack", pcp: 0, source: "compromisedNode", destination: "mainECU"}]
*.centralSwitch.bridging.streamCoder.decoder.mapping += [{pcp: 4, stream: "sensor_monitoring"}]
*.centralSwitch.bridging.streamCoder.decoder.mapping += [{pcp: 4, destination: "display", stream: "sensor_monitoring"}]
*.centralSwitch.bridging.streamCoder.decoder.mapping += [{stream: "sensor_monitoring", packetFilter: expr(has(udp) && udp.destPort == 7000)}]
*.centralSwitch.bridging.streamCoder.encoder.mapping += [{stream: "sensor_monitoring", pcp: 4, vlan: 25}]
*.centralSwitch.bridging.streamCoder.decoder.mapping += [{destination: "01:80:C2:00:00:0E", stream: "gptp"}]
*.centralSwitch.bridging.streamCoder.decoder.mapping += [{packetFilter: expr(ethernetMacHeader.typeOrLength == 0x88f7), stream: "gptp"}]
*.centralSwitch.bridging.streamCoder.decoder.mapping += [{pcp: 0, stream: "default_stream"}]
 
# On the central switch, identify gPTP by L2 indication or EtherType,
# so the classifier sees stream="gptp" even when no tag is present yet.
*.centralSwitch.bridging.streamIdentifier.identifier.mapping += [{stream: "gptp", packetFilter: expr(has(etherTypeInd) && etherTypeInd.etherType == 0x88f7)}]
# Fallback (if your build balks at etherTypeInd), match header field:
*.centralSwitch.bridging.streamIdentifier.identifier.mapping += [{stream: "gptp", packetFilter: expr(ethernetMacHeader.typeOrLength == 0x88f7)}]
*.centralSwitch.bridging.streamIdentifier.identifier.mapping += [{stream: "gptp", packetFilter: expr(etherType == 0x88f7)}]
*.centralSwitch.bridging.streamIdentifier.identifier.mapping += [{stream: "gptp", packetFilter: expr(destAddress == "01:80:C2:00:00:0E")}]

# ---- PSFP Stream Filtering Configuration ----
# Full implementation of IEEE 802.1Qci stream filtering
*.centralSwitch.bridging.streamFilter.ingress.numStreams = 8
*.centralSwitch.bridging.streamFilter.ingress.classifier.mapping = {"critical_control": 0, "status_updates": 1, "external_attack": 2, "compromised_attack": 3, "display_data": 4, "gptp": 5, "default_stream": 6, "sensor_monitoring": 7}
*.centralSwitch.bridging.streamFilter.ingress.hasDefaultPath = false # fail closed for unknown streams per 802.1Qci
*.centralSwitch.bridging.streamFilter.ingress.classifier.mode = "both"
*.centralSwitch.bridging.streamFilter.ingress.classifier.defaultGateIndex = 5

# ---- PSFP Stream Metering (Traffic Policing) ----
# Use INET queueing meter that implements IPacketMeter
*.centralSwitch.bridging.streamFilter.ingress.meter[*].typename = "DualRateThreeColorMeter"

# PSFP Meter Display Names (for monitoring and debugging)
*.centralSwitch.bridging.streamFilter.ingress.meter[0].display-name = "critical_control"
*.centralSwitch.bridging.streamFilter.ingress.meter[1].display-name = "status_updates"
*.centralSwitch.bridging.streamFilter.ingress.meter[2].display-name = "external_attack"
*.centralSwitch.bridging.streamFilter.ingress.meter[3].display-name = "compromised_attack"
*.centralSwitch.bridging.streamFilter.ingress.meter[4].display-name = "display_data"

# ---- PSFP Committed Information Rate (CIR) Configuration ----
# Critical control traffic - highest priority, generous allocation
*.centralSwitch.bridging.streamFilter.ingress.meter[0].committedInformationRate = 10Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[0].committedBurstSize = 5kB
*.centralSwitch.bridging.streamFilter.ingress.meter[0].excessInformationRate = 5Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[0].excessBurstSize = 3kB

# Status updates - medium priority
*.centralSwitch.bridging.streamFilter.ingress.meter[1].committedInformationRate = 5Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[1].committedBurstSize = 3kB
*.centralSwitch.bridging.streamFilter.ingress.meter[1].excessInformationRate = 2Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[1].excessBurstSize = 1kB

# Attack traffic - low priority, limited allocation for detection
*.centralSwitch.bridging.streamFilter.ingress.meter[2].committedInformationRate = 50kbps
*.centralSwitch.bridging.streamFilter.ingress.meter[2].committedBurstSize = 256B
*.centralSwitch.bridging.streamFilter.ingress.meter[2].excessInformationRate = 25kbps
*.centralSwitch.bridging.streamFilter.ingress.meter[2].excessBurstSize = 128B

*.centralSwitch.bridging.streamFilter.ingress.meter[3].committedInformationRate = 50kbps
*.centralSwitch.bridging.streamFilter.ingress.meter[3].committedBurstSize = 256B
*.centralSwitch.bridging.streamFilter.ingress.meter[3].excessInformationRate = 25kbps
*.centralSwitch.bridging.streamFilter.ingress.meter[3].excessBurstSize = 128B
*.centralSwitch.bridging.streamFilter.ingress.meter[4].committedInformationRate = 2Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[4].committedBurstSize = 2kB
*.centralSwitch.bridging.streamFilter.ingress.meter[4].excessInformationRate = 1Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[4].excessBurstSize = 1kB
*.centralSwitch.bridging.streamFilter.ingress.meter[5].display-name = "gptp"
*.centralSwitch.bridging.streamFilter.ingress.meter[5].committedInformationRate = 1Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[5].committedBurstSize = 1kB
*.centralSwitch.bridging.streamFilter.ingress.meter[5].excessInformationRate = 1Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[5].excessBurstSize = 1kB
*.centralSwitch.bridging.streamFilter.ingress.meter[6].display-name = "default_stream"
*.centralSwitch.bridging.streamFilter.ingress.meter[6].committedInformationRate = 1bps
*.centralSwitch.bridging.streamFilter.ingress.meter[6].committedBurstSize = 1B
*.centralSwitch.bridging.streamFilter.ingress.meter[6].excessInformationRate = 1bps
*.centralSwitch.bridging.streamFilter.ingress.meter[6].excessBurstSize = 1B

# PCP4 sensor monitoring stream limits (realistic medium priority)
*.centralSwitch.bridging.streamFilter.ingress.meter[7].display-name = "sensor_monitoring"
*.centralSwitch.bridging.streamFilter.ingress.meter[7].committedInformationRate = 3Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[7].committedBurstSize = 2kB
*.centralSwitch.bridging.streamFilter.ingress.meter[7].excessInformationRate = 1Mbps
*.centralSwitch.bridging.streamFilter.ingress.meter[7].excessBurstSize = 1kB

# Enforce per-stream filtering: drop non-conforming by default; allow yellow for gPTP
*.centralSwitch.bridging.streamFilter.ingress.filter[5].labelFilter = "green or yellow"

# ---- PSFP Stream Identification in End Devices ----
# Critical Sensor stream identification
*.criticalSensor.bridging.streamIdentifier.identifier.mapping = [{stream: "critical_control", packetFilter: expr(has(udp) && udp.destPort == 5000)}]
*.criticalSensor.bridging.streamCoder.encoder.mapping = [{stream: "critical_control", pcp: 7, vlan: 10}]

# Main ECU stream identification  
*.mainECU.bridging.streamIdentifier.identifier.mapping = [{stream: "status_updates", packetFilter: expr(has(udp) && udp.destPort == 6000)}]
*.mainECU.bridging.streamCoder.encoder.mapping = [{stream: "status_updates", pcp: 5, vlan: 30}]
*.criticalSensor.bridging.streamIdentifier.identifier.mapping += [{stream: "sensor_monitoring", packetFilter: expr(has(udp) && udp.destPort == 7000)}]
*.criticalSensor.bridging.streamCoder.encoder.mapping += [{stream: "sensor_monitoring", pcp: 4, vlan: 25}]

# Display device stream handling
*.display.bridging.streamIdentifier.identifier.mapping = [{stream: "display_data", packetFilter: expr(has(udp) && udp.destPort == 6003)}]
*.display.bridging.streamCoder.encoder.mapping = [{stream: "display_data", pcp: 3, vlan: 20}]

# Attack device stream identification (for analysis)
*.attackerExternal.bridging.streamIdentifier.identifier.mapping = [{stream: "external_attack", packetFilter: expr(has(udp) && udp.destPort == 5000)}]
*.attackerExternal.bridging.streamCoder.encoder.mapping = [{stream: "external_attack", pcp: 0, vlan: 40}]

*.compromisedNode.bridging.streamIdentifier.identifier.mapping = [{stream: "compromised_attack", packetFilter: expr(has(udp) && (udp.destPort == 8888 || udp.destPort == 5000))}]
# removed invalid gPTP mapping expression to avoid 'etherType' eval error; classify gPTP later via proper tag or decoder
*.compromisedNode.bridging.streamCoder.encoder.mapping = [{stream: "compromised_attack", pcp: 0, vlan: 41}]

# Ensure all talkers have outgoing stream coding enabled
*.criticalSensor.hasOutgoingStreams = true
*.display.hasOutgoingStreams = true
*.attackerExternal.hasOutgoingStreams = true
*.compromisedNode.hasOutgoingStreams = true
*.mainECU.hasOutgoingStreams = true
*.masterClock.hasOutgoingStreams = true

# gPTP tagging at the talker (priority-tagged)
*.masterClock.bridging.streamIdentifier.identifier.mapping = [{stream: "gptp", packetFilter: expr(etherType == 0x88f7)}]
*.masterClock.bridging.streamCoder.encoder.mapping = [{stream: "gptp", pcp: 6, vlan: 0}]

# Catch-all default streams at talkers (last entry), to guarantee VLAN/PCP
*.criticalSensor.bridging.streamIdentifier.identifier.mapping += [{stream: "default_stream", packetFilter: expr(true)}]
*.criticalSensor.bridging.streamCoder.encoder.mapping        += [{stream: "default_stream",  pcp: 0, vlan: 0}]
*.display.bridging.streamIdentifier.identifier.mapping       += [{stream: "default_stream", packetFilter: expr(true)}]
*.display.bridging.streamCoder.encoder.mapping               += [{stream: "default_stream",  pcp: 0, vlan: 0}]
*.attackerExternal.bridging.streamIdentifier.identifier.mapping += [{stream: "default_stream", packetFilter: expr(true)}]
*.attackerExternal.bridging.streamCoder.encoder.mapping         += [{stream: "default_stream",  pcp: 0, vlan: 0}]
*.compromisedNode.bridging.streamIdentifier.identifier.mapping  += [{stream: "default_stream", packetFilter: expr(true)}]
*.compromisedNode.bridging.streamCoder.encoder.mapping          += [{stream: "default_stream",  pcp: 0, vlan: 0}]
*.mainECU.bridging.streamIdentifier.identifier.mapping          += [{stream: "default_stream", packetFilter: expr(true)}]
*.mainECU.bridging.streamCoder.encoder.mapping                  += [{stream: "default_stream",  pcp: 0, vlan: 0}]

# ---- IEEE 802.1Qbv Time-Aware Shaping (TAS) Configuration ----
# Full 8-priority traffic class implementation
*.centralSwitch.eth[*].macLayer.queue.numTrafficClasses = 8
*.centralSwitch.eth[*].macLayer.queue.classifier.typename = "PcpClassifier"
*.centralSwitch.eth[*].macLayer.queue.classifier.pcpToGateIndex = [0, 1, 2, 3, 4, 5, 6, 7]

# ---- PSFP Gate Control Configuration ----
# Implements time-aware gate control per IEEE 802.1Qbv
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[*].typename = "PeriodicGate"
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[7].durations = [250us, 250us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[6].durations = [200us, 300us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[5].durations = [150us, 350us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[4].durations = [100us, 400us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[3].durations = [100us, 400us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[2].durations = [50us, 450us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[1].durations = [50us, 450us]
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[0].durations = [25us, 475us]

# ---- PSFP Administrative Configuration ----
# Enable comprehensive PSFP features across all switches
*.centralSwitch.hasStreamRedundancy = false  # Simplified for minimal topology
*.centralSwitch.hasIngressTrafficFiltering = true
*.centralSwitch.bridging.streamIdentifier.typename = "StreamIdentifierLayer"
*.centralSwitch.bridging.streamIdentifier.identifier.typename = "StreamIdentifier"
*.centralSwitch.hasEgressTrafficShaping = true
*.centralSwitch.hasStreamFiltering = true
*.centralSwitch.hasStreamPolicing = true

# ---- PSFP Operational Parameters ----
# Keep parameters compatible with DualRateThreeColorMeter
*.centralSwitch.bridging.streamFilter.ingress.meter[*].colorAware = false

# ============================================================================
# TSN & PSFP METRICS RECORDING CONFIGURATION 
# ============================================================================
# 
# COMPREHENSIVE data collection for PSFP analysis and ML training.
# This section records ALL critical TSN and PSFP metrics without simplification.
# Essential for understanding PSFP behavior and training ML models.
# ============================================================================

# ---- Core TSN Performance Metrics ----
# 1. End-to-End Delay Metrics (Critical for TSN timing analysis)
**.app[*].endToEndDelay:vector.result-recording-modes = all
**.app[*].endToEndDelay:vector.vector-recording = true
**.app[*].endToEndDelay:histogram.result-recording-modes = all

# 2. Throughput and Bandwidth Metrics
**.bitrate:vector.result-recording-modes = all
**.bitrate:vector.vector-recording = true
**.throughput:vector.result-recording-modes = all
**.throughput:vector.vector-recording = true
**.datarate:vector.result-recording-modes = all
**.datarate:vector.vector-recording = true

# 3. Queue Management Metrics (Essential for PSFP analysis)
**.queue.queueLength:vector.result-recording-modes = all
**.queue.queueLength:vector.vector-recording = true
**.queue.queueingTime:vector.result-recording-modes = all
**.queue.queueingTime:vector.vector-recording = true
**.queue.queueBitLength:vector.result-recording-modes = all
**.queue.queueBitLength:vector.vector-recording = true

# 4. Packet Statistics (Attack detection features)
**.packetDropped:count.result-recording-modes = all
**.packetDropped:vector.result-recording-modes = all
**.packetDropped:vector.vector-recording = true
**.packetSent:count.result-recording-modes = all
**.packetReceived:count.result-recording-modes = all
**.rxPkOk:count.result-recording-modes = all
**.rxPkOk:vector.result-recording-modes = all
**.txPk:count.result-recording-modes = all
**.txPk:vector.result-recording-modes = all

# ---- PSFP-Specific Metrics (CORE PROJECT FOUNDATION) ----
# 5. Stream Filtering and Policing Metrics
**.bridging.streamFilter.ingress.meter[*].committedConformingPackets:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedConformingPackets:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedConformingPackets:vector.vector-recording = true

**.bridging.streamFilter.ingress.meter[*].committedNonConformingPackets:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedNonConformingPackets:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].committedNonConformingPackets:vector.vector-recording = true

**.bridging.streamFilter.ingress.meter[*].excessConformingPackets:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].excessConformingPackets:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].excessConformingPackets:vector.vector-recording = true

**.bridging.streamFilter.ingress.meter[*].packetFiltered:count.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].packetFiltered:vector.result-recording-modes = all
**.bridging.streamFilter.ingress.meter[*].packetFiltered:vector.vector-recording = true

# 6. Stream Classification Metrics
**.bridging.streamCoder.packetEncoded:count.result-recording-modes = all
**.bridging.streamCoder.packetDecoded:count.result-recording-modes = all
**.bridging.streamIdentifier.packetClassified:count.result-recording-modes = all
**.bridging.streamIdentifier.packetClassified:vector.result-recording-modes = all
**.bridging.streamIdentifier.packetClassified:vector.vector-recording = true

# 7. Time-Aware Shaping Metrics
**.queue.transmissionGate[*].gateStateChanged:vector.result-recording-modes = all
**.queue.transmissionGate[*].gateStateChanged:vector.vector-recording = true
**.queue.transmissionSelectionAlgorithm[*].credit:vector.result-recording-modes = all
**.queue.transmissionSelectionAlgorithm[*].credit:vector.vector-recording = true

# 8. TSN Time Synchronization Metrics (gPTP)
**.gptp.clockServo.offsetNanoseconds:vector.result-recording-modes = all
**.gptp.clockServo.offsetNanoseconds:vector.vector-recording = true
**.gptp.clockServo.driftPpm:vector.result-recording-modes = all
**.gptp.clockServo.driftPpm:vector.vector-recording = true
**.gptp.clockServo.rateRatio:vector.result-recording-modes = all
**.gptp.clockServo.rateRatio:vector.vector-recording = true

# 9. MAC Layer Metrics (Critical for timing analysis)
**.mac.txPk:count.result-recording-modes = all
**.mac.rxPkOk:count.result-recording-modes = all
**.mac.frameSequenceErrors:count.result-recording-modes = all
**.mac.alignmentErrors:count.result-recording-modes = all

# 10. Physical Layer Metrics
**.phy.txPk:count.result-recording-modes = all
**.phy.rxPkOk:count.result-recording-modes = all
**.phy.symbolErrors:count.result-recording-modes = all

# ---- Attack Detection Specific Metrics ----
# 11. Flow-based metrics for anomaly detection
**.ipv4.routingTable.routeAdded:count.result-recording-modes = all
**.ipv4.routingTable.routeDeleted:count.result-recording-modes = all
**.udp.packetSent:count.result-recording-modes = all
**.udp.packetReceived:count.result-recording-modes = all
**.udp.passedUpPk:count.result-recording-modes = all

# 12. Priority-based traffic analysis
**.pcp0:count.result-recording-modes = all
**.pcp1:count.result-recording-modes = all
**.pcp2:count.result-recording-modes = all
**.pcp3:count.result-recording-modes = all
**.pcp4:count.result-recording-modes = all
**.pcp5:count.result-recording-modes = all
**.pcp6:count.result-recording-modes = all
**.pcp7:count.result-recording-modes = all

# ---- Attack Applications Configuration ----
# Disabled by default, enabled in specific attack scenarios
*.attackerExternal.numApps = 0
*.compromisedNode.numApps = 0

# ---- Visualization Configuration ----
*.visualizer.typename = "IntegratedCanvasVisualizer"

# Data link activity visualization
*.visualizer.dataLinkVisualizer.displayLinks = true
*.visualizer.dataLinkVisualizer.activityLevel = "protocol"
*.visualizer.dataLinkVisualizer.fadeOutMode = "simulationTime"
*.visualizer.dataLinkVisualizer.fadeOutTime = 0.2s

# Statistical visualization
*.visualizer.statisticVisualizer.displayStatistics = true
*.visualizer.statisticVisualizer.signalName = "packetReceived"
*.visualizer.statisticVisualizer.sourceFilter = "**.app[*]"
*.visualizer.statisticVisualizer.format = "count"

# ---- DATA COLLECTOR CONFIGURATION ----
# Configure DataCollector for time-windowed CSV output optimized for ML
*.dataCollector.outputFile = "results_flat/tsn_signals_${configname}-#${repetition}.csv"
*.dataCollector.windowLength = 1ms
*.dataCollector.emitCSV = true
*.dataCollector.emitPCPBreakdowns = false
*.dataCollector.emitRaw = false
*.dataCollector.emitNDJSON = false
*.dataCollector.emitPerStreamRows = true
*.dataCollector.includeControlFramesInThroughput = true
*.dataCollector.emitZeroIfNoSamples = false

# ---- Background low-rate UDP stream to exercise throughput ----
*.mainECU.numApps = 4
*.mainECU.app[3].typename = "UdpBasicApp"
*.mainECU.app[3].localPort = 6100
*.mainECU.app[3].destAddresses = "display"
*.mainECU.app[3].destPort = 6000
*.mainECU.app[3].messageLength = 256B
*.mainECU.app[3].sendInterval = 2ms
*.mainECU.app[3].startTime = 10ms
*.mainECU.app[3].stopTime = 0.5s

# ---- TSN ML INFERENCE ENGINE CONFIGURATION ----
# Configure ML inference engine for real-time attack detection
*.mlInferenceEngine.modelPath = "../ml_models/tsn_extended_fdeep.json"
*.mlInferenceEngine.normPath = "../ml_models/tsn_extended_norm.json"
*.mlInferenceEngine.inferenceInterval = 1ms
*.mlInferenceEngine.anomalyThreshold = 0.7

# Keep results in a single flat directory (no nesting)
result-dir = "results_flat"
output-scalar-file = "${resultdir}/${configname}-${repetition}.sca"
output-vector-file = "${resultdir}/${configname}-${repetition}.vec"


# ---- LIGHTWEIGHT ML FEATURE COLLECTION ----
# Keep .vec small: rely on JSON; selectively enable vectors only when debugging
**.result-recording-modes = default
**.vector-recording = false
**.scalar-recording = false

# Optional minimal vectors for debugging (comment out if not needed)
# **.app[*].endToEndDelay:vector.vector-recording = true
# **.queue.queueLength:vector.vector-recording = true
# **.packetDropped:count.result-recording-modes = all

# Note: DataCollector subscribes to signals directly without recording to .vec files
# This produces a single JSON file with ML-ready features per scenario

# =================================================================
# ATTACK SCENARIO CONFIGURATIONS (4 scenarios for ML training)
# Each scenario runs for 500ms with predetermined attack timing
# =================================================================





[Config Baseline]
extends = General
description = "Baseline: Normal TSN operation without attacks (Label: normal)"

# Fail-closed in Baseline too; rely on gPTP identification rules above
*.centralSwitch.bridging.streamFilter.ingress.hasDefaultPath = false

# === NORMAL TSN TRAFFIC APPLICATIONS ===
# Critical sensor -> mainECU (real-time safety-critical) + sensor monitoring (PCP4)
*.criticalSensor.numApps = 2
*.criticalSensor.app[0].typename = "UdpSourceApp"
*.criticalSensor.app[0].source.packetNameFormat = "CRITICAL_SENSOR-%c"
*.criticalSensor.app[0].source.packetLength = 175B
*.criticalSensor.app[0].source.productionInterval = 1ms  # 1kHz safety sensor
*.criticalSensor.app[0].source.startTime = 10ms
*.criticalSensor.app[0].io.destAddress = "mainECU"
*.criticalSensor.app[0].io.destPort = 5000

*.criticalSensor.app[1].typename = "UdpSourceApp"
*.criticalSensor.app[1].source.packetNameFormat = "SENSOR_MON-%c"
*.criticalSensor.app[1].source.packetLength = 150B
*.criticalSensor.app[1].source.productionInterval = 50ms
*.criticalSensor.app[1].source.startTime = 12ms
*.criticalSensor.app[1].io.destAddress = "display"
*.criticalSensor.app[1].io.destPort = 7000

# Display unit: sinks for status_updates (6000) and sensor_monitoring (7000), plus source for display_data (6003)
*.display.numApps = 3
*.display.app[0].typename = "UdpSinkApp"
*.display.app[0].io.localPort = 6000
*.display.app[1].typename = "UdpSinkApp"
*.display.app[1].io.localPort = 7000
*.display.app[2].typename = "UdpSourceApp"
*.display.app[2].source.packetNameFormat = "DISPLAY_UPDATE-%c"
*.display.app[2].source.packetLength = 120B
*.display.app[2].source.productionInterval = 50ms
*.display.app[2].source.startTime = 15ms
*.display.app[2].io.destAddress = "mainECU"
*.display.app[2].io.destPort = 6003

# mainECU: sink for critical (5000); source for status_updates (6000); sink for display_data (6003)
*.mainECU.numApps = 3
*.mainECU.app[0].typename = "UdpSinkApp"
*.mainECU.app[0].io.localPort = 5000
*.mainECU.app[1].typename = "UdpSourceApp"
*.mainECU.app[1].source.packetNameFormat = "STATUS_UPDATE-%c"
*.mainECU.app[1].source.packetLength = 100B
*.mainECU.app[1].source.productionInterval = 10ms
*.mainECU.app[1].source.startTime = 20ms
*.mainECU.app[1].io.destAddress = "display"
*.mainECU.app[1].io.destPort = 6000
*.mainECU.app[2].typename = "UdpSinkApp"
*.mainECU.app[2].io.localPort = 6003

# display sinks already set above

[Config DoSAttack] 
extends = Baseline  # Include normal traffic + DoS attack
description = "DoS flooding attack targeting critical systems (Label: dos_attack)"

# DoS attack: High-rate flooding starting at 100ms, ending at 400ms - TSN AGGRESSIVE
*.attackerExternal.numApps = 1
*.attackerExternal.app[0].typename = "UdpSourceApp"
*.attackerExternal.app[0].source.packetNameFormat = "DOS_FLOOD-%c"
*.attackerExternal.app[0].source.packetLength = 1500B  # Maximum Ethernet frame
*.attackerExternal.app[0].source.productionInterval = 5us  # 200kHz attack rate
*.attackerExternal.app[0].source.startTime = 100ms
*.attackerExternal.app[0].source.stopTime = 400ms
*.attackerExternal.app[0].io.destAddress = "mainECU"
*.attackerExternal.app[0].io.destPort = 5000  # Target critical sensor port

# Ensure DoS frames are VLAN/PCP encoded at the talker (post-classification consistency)
*.attackerExternal.bridging.streamCoder.typename = "StreamCoderLayer"

[Config TimingAttack]
extends = Baseline  # Include normal traffic + timing attack
description = "Timing attack disrupting TSN synchronization (Label: timing_attack)"

# Severe clock drift attack
*.compromisedNode.clock.oscillator.driftRate = 500ppm  # Very high drift

# Timing disruption packets - targeting centralSwitch instead of masterClock
*.compromisedNode.numApps = 1
*.compromisedNode.app[0].typename = "UdpSourceApp"
*.compromisedNode.app[0].source.packetNameFormat = "TIMING_ATTACK-%c"
*.compromisedNode.app[0].source.packetLength = 64B
*.compromisedNode.app[0].source.productionInterval = uniform(10us, 100us)  # Random timing
*.compromisedNode.app[0].source.startTime = 50ms
*.compromisedNode.app[0].source.stopTime = 450ms
*.compromisedNode.app[0].io.destAddress = "mainECU"
*.compromisedNode.app[0].io.destPort = 8888

# Starve gPTP (PCP 6) on the central switch: gate mostly closed
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[6].initiallyOpen = false
*.centralSwitch.eth[*].macLayer.queue.transmissionGate[6].durations = [490us, 10us]

[Config SpoofingAttack]
extends = Baseline  # Include normal traffic + spoofing attack
description = "Spoofing attack impersonating critical sensor (Label: spoofing_attack)"

# Compromised node impersonates critical sensor - TSN AGGRESSIVE SPOOFING
*.compromisedNode.numApps = 1
*.compromisedNode.app[0].typename = "UdpSourceApp"
*.compromisedNode.app[0].source.packetNameFormat = "SPOOFED_SENSOR-%c"
*.compromisedNode.app[0].source.packetLength = 175B  # Match legitimate sensor
*.compromisedNode.app[0].source.productionInterval = 100us  # 10x faster than TSN standard
*.compromisedNode.app[0].source.startTime = 150ms
*.compromisedNode.app[0].source.stopTime = 350ms
*.compromisedNode.app[0].io.destAddress = "mainECU"
*.compromisedNode.app[0].io.destPort = 5000  # Same port as critical sensor

# Encode to match critical_control PCP/VLAN to simulate true spoofing
*.compromisedNode.bridging.streamIdentifier.identifier.mapping = [{stream: "critical_control", packetFilter: expr(has(udp) && udp.destPort == 5000)}]
*.compromisedNode.bridging.streamCoder.encoder.mapping = [{stream: "critical_control", pcp: 7, vlan: 10}]
