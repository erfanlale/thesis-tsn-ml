#include "DataCollector.h"
#include <iostream>
#include <iomanip>

Define_Module(DataCollector);

DataCollector::DataCollector()
{
    csvOutputFile = "ml_training_data.csv";
    firstRun = true;
}

DataCollector::~DataCollector()
{
    // Cleanup handled in finish()
}

void DataCollector::initialize()
{
    EV_INFO << "🎯 Initializing focused DataCollector for ML training..." << endl;
    
    // Register and subscribe to key TSN/PSFP signals
    endToEndDelaySignal = registerSignal("endToEndDelay");
    psfpConformingSignal = registerSignal("committedConformingPackets");
    psfpViolationsSignal = registerSignal("committedNonConformingPackets");
    queueLengthSignal = registerSignal("queueLength");
    timeSyncOffsetSignal = registerSignal("offsetNanoseconds");
    packetsSentSignal = registerSignal("packetSent");
    packetsReceivedSignal = registerSignal("packetReceived");
    
    // Subscribe to signals across all modules using wildcard patterns
    getSimulation()->getSystemModule()->subscribe("*.app[*].endToEndDelay", this);
    getSimulation()->getSystemModule()->subscribe("*.centralSwitch.bridging.streamFilter.ingress.meter[*].committedConformingPackets", this);
    getSimulation()->getSystemModule()->subscribe("*.centralSwitch.bridging.streamFilter.ingress.meter[*].committedNonConformingPackets", this);
    getSimulation()->getSystemModule()->subscribe("*.centralSwitch.eth[*].queue.queueLength", this);
    getSimulation()->getSystemModule()->subscribe("*.*.gptp.clockServo.offsetNanoseconds", this);
    getSimulation()->getSystemModule()->subscribe("*.app[*].packetSent", this);
    getSimulation()->getSystemModule()->subscribe("*.app[*].packetReceived", this);
    
    EV_INFO << "✅ DataCollector subscribed to 7 key TSN/PSFP signals" << endl;
    
    std::ifstream checkFile(csvOutputFile);
    firstRun = !checkFile.good();
    checkFile.close();
    
    if (firstRun) {
        writeCSVHeader();
        EV_INFO << "📊 Created new CSV file: " << csvOutputFile << endl;
    } else {
        EV_INFO << "📊 Appending to existing CSV file: " << csvOutputFile << endl;
    }
}

void DataCollector::finish()
{
    EV_INFO << "🏁 DataCollector finishing - writing ML training row..." << endl;
    writeCSVRow();
    
    std::string scenario = getScenarioLabel();
    EV_INFO << "📋 Final Statistics for scenario: " << scenario << endl;
    EV_INFO << "   End-to-end delay: count=" << endToEndDelayCount 
            << ", mean=" << calculateMean(endToEndDelayCount, endToEndDelaySum) << endl;
    EV_INFO << "   PSFP conforming: count=" << psfpConformingCount << endl;
    EV_INFO << "   PSFP violations: count=" << psfpNonConformingCount << endl;
    EV_INFO << "   Queue length: count=" << queueLengthCount << endl;
    EV_INFO << "   Packets sent: " << packetsSentSum << endl;
    EV_INFO << "   Packets received: " << packetsReceivedSum << endl;
    EV_INFO << "✅ ML training data written successfully!" << endl;
}

void DataCollector::receiveSignal(cComponent *source, simsignal_t signalID, cObject *obj, cObject *details)
{
    // Handle object-based signals if needed
}

void DataCollector::receiveSignal(cComponent *source, simsignal_t signalID, const SimTime& t, cObject *details)
{
    // Handle time-based signals if needed  
}

void DataCollector::receiveSignal(cComponent *source, simsignal_t signalID, double value, cObject *details)
{
    updateStatistics(signalID, value);
}

void DataCollector::receiveSignal(cComponent *source, simsignal_t signalID, long value, cObject *details)
{
    updateStatistics(signalID, (double)value);
}

void DataCollector::updateStatistics(simsignal_t signalID, double value)
{
    const char* signalName = cComponent::getSignalName(signalID);
    
    if (strcmp(signalName, "endToEndDelay") == 0) {
        endToEndDelayCount++;
        endToEndDelaySum += value;
        endToEndDelayMax = std::max(endToEndDelayMax, value);
        endToEndDelayMin = std::min(endToEndDelayMin, value);
    }
    else if (strcmp(signalName, "committedConformingPackets") == 0) {
        psfpConformingCount++;
        psfpConformingSum += value;
        psfpConformingMax = std::max(psfpConformingMax, value);
        psfpConformingMin = std::min(psfpConformingMin, value);
    }
    else if (strcmp(signalName, "committedNonConformingPackets") == 0) {
        psfpNonConformingCount++;
        psfpViolationsSum += value;
        psfpViolationsMax = std::max(psfpViolationsMax, value);
        psfpViolationsMin = std::min(psfpViolationsMin, value);
    }
    else if (strcmp(signalName, "queueLength") == 0) {
        queueLengthCount++;
        queueLengthSum += value;
        queueLengthMax = std::max(queueLengthMax, value);
        queueLengthMin = std::min(queueLengthMin, value);
    }
    else if (strcmp(signalName, "offsetNanoseconds") == 0) {
        timeSyncOffsetCount++;
        timeSyncOffsetSum += value;
        timeSyncOffsetMax = std::max(timeSyncOffsetMax, value);
        timeSyncOffsetMin = std::min(timeSyncOffsetMin, value);
    }
    else if (strcmp(signalName, "packetSent") == 0) {
        packetsSentCount++;
        packetsSentSum += value;
        packetsSentMax = std::max(packetsSentMax, value);
        packetsSentMin = std::min(packetsSentMin, value);
    }
    else if (strcmp(signalName, "packetReceived") == 0) {
        packetsReceivedCount++;
        packetsReceivedSum += value;
        packetsReceivedMax = std::max(packetsReceivedMax, value);
        packetsReceivedMin = std::min(packetsReceivedMin, value);
    }
}

void DataCollector::writeCSVHeader()
{
    std::ofstream csvFile(csvOutputFile, std::ios::app);
    if (!csvFile.is_open()) {
        EV_ERROR << "❌ Failed to open CSV file: " << csvOutputFile << endl;
        return;
    }
    
    csvFile << "scenario_label,"
            << "delay_count,delay_mean,delay_max,delay_min,"
            << "psfp_conforming_count,psfp_conforming_total,psfp_conforming_max,psfp_conforming_min,"
            << "psfp_violations_count,psfp_violations_total,psfp_violations_max,psfp_violations_min,"
            << "queue_count,queue_mean,queue_max,queue_min,"
            << "time_sync_count,time_sync_mean,time_sync_max,time_sync_min,"
            << "packets_sent_count,packets_sent_total,packets_sent_max,packets_sent_min,"
            << "packets_received_count,packets_received_total,packets_received_max,packets_received_min"
            << std::endl;
    
    csvFile.close();
}

void DataCollector::writeCSVRow()
{
    std::ofstream csvFile(csvOutputFile, std::ios::app);
    if (!csvFile.is_open()) {
        EV_ERROR << "❌ Failed to open CSV file: " << csvOutputFile << endl;
        return;
    }
    
    csvFile << std::fixed << std::setprecision(9);
    
    csvFile << getScenarioLabel() << ","
            << endToEndDelayCount << ","
            << calculateMean(endToEndDelayCount, endToEndDelaySum) << ","
            << endToEndDelayMax << ","
            << (endToEndDelayMin == std::numeric_limits<double>::max() ? 0.0 : endToEndDelayMin) << ","
            << psfpConformingCount << ","
            << psfpConformingSum << ","
            << psfpConformingMax << ","
            << (psfpConformingMin == std::numeric_limits<double>::max() ? 0.0 : psfpConformingMin) << ","
            << psfpNonConformingCount << ","
            << psfpViolationsSum << ","
            << psfpViolationsMax << ","
            << (psfpViolationsMin == std::numeric_limits<double>::max() ? 0.0 : psfpViolationsMin) << ","
            << queueLengthCount << ","
            << calculateMean(queueLengthCount, queueLengthSum) << ","
            << queueLengthMax << ","
            << (queueLengthMin == std::numeric_limits<double>::max() ? 0.0 : queueLengthMin) << ","
            << timeSyncOffsetCount << ","
            << calculateMean(timeSyncOffsetCount, timeSyncOffsetSum) << ","
            << timeSyncOffsetMax << ","
            << (timeSyncOffsetMin == std::numeric_limits<double>::max() ? 0.0 : timeSyncOffsetMin) << ","
            << packetsSentCount << ","
            << packetsSentSum << ","
            << packetsSentMax << ","
            << (packetsSentMin == std::numeric_limits<double>::max() ? 0.0 : packetsSentMin) << ","
            << packetsReceivedCount << ","
            << packetsReceivedSum << ","
            << packetsReceivedMax << ","
            << (packetsReceivedMin == std::numeric_limits<double>::max() ? 0.0 : packetsReceivedMin)
            << std::endl;
    
    csvFile.close();
    EV_INFO << "✅ Wrote CSV row for scenario: " << getScenarioLabel() << endl;
}

std::string DataCollector::getScenarioLabel()
{
    std::string configName = getEnvir()->getConfigEx()->getActiveConfigName();

    // Map configuration names to standard ML labels
    if (configName == "Baseline") return "normal";
    else if (configName == "DoSAttack") return "dos";
    else if (configName == "TimingAttack") return "timing";
    else if (configName == "SpoofingAttack") return "spoofing";
    else return configName; // Use original name if not recognized
}

double DataCollector::calculateMean(long count, double sum)
{
    return count > 0 ? sum / count : 0.0;
}
